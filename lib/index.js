// Generated by CoffeeScript 2.5.1
(function() {
  var Command, OtrgenCommand, TurndownService, arg, decodeEntities, flags, fs, html2Markdown, markdown2Html, markdownTimestamp, mdtsRE, options, otrTimestamp, parseBlock, tsRE, ttml2sbv, ttmlRE;

  ({Command, flags} = require('@oclif/command'));

  TurndownService = require('turndown');

  fs = require('fs').promises;

  tsRE = /(?<h>\d):(?<m>\d\d):(?<s>\d\d)\.(?<ms>\d\d\d)/;

  ttmlRE = /^<p begin="(?<ts1>[\d:.]*)" end="(?<ts2>[\d:.]*)" style="s2">(?<text>.*?)<\/p>$/;

  mdtsRE = /<t ms=(?<ms>\d+)>(?<m>\d\d):(?<s>\d\d)<\/t>/;

  decodeEntities = function(encodedString) {
    return encodedString.replace(/&#(\d+);/gi, function(match, numStr) {
      return String.fromCharCode(parseInt(numStr, 10));
    });
  };

  otrTimestamp = function(timestamp) {
    var groups, h, html, m, matches, ms, s, seconds;
    matches = timestamp.match(tsRE);
    groups = matches.groups;
    // Convert timestamp to seconds
    h = parseInt(groups.h, 10);
    m = parseInt(groups.m, 10);
    s = parseInt(groups.s, 10);
    ms = parseInt(groups.ms, 10);
    seconds = h * 3600 + m * 60 + s + ms / 1000;
    return html = `<span class="timestamp" data-timestamp="${seconds}">${groups.m}:${groups.s}</span>`;
  };

  markdownTimestamp = function(timestamp) {
    var groups, markdown, matches;
    matches = timestamp.match(tsRE);
    groups = matches.groups;
    return markdown = `<t ms=${groups.ms}>${groups.m}:${groups.s}</t>`;
  };

  ttml2sbv = function(lines) {
    var groups, i, len, line, matches, results;
    results = [];
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      matches = line.match(ttmlRE);
      if (matches) {
        groups = matches.groups;
        results.push(`${groups.ts1}, ${groups.ts2}`);
        results.push(`${decodeEntities(groups.text)}`);
        results.push("");
      }
    }
    return results;
  };

  parseBlock = function(lines) {
    var endTs, otrStartTs, result, startTs, text, timestamps;
    timestamps = lines.shift();
    text = lines.shift();
    lines.shift();
    if (!timestamps || !text) {
      return;
    }
    [startTs, endTs] = timestamps.split(',');
    otrStartTs = otrTimestamp(startTs);
    return result = {
      ts: startTs,
      text: text
    };
  };

  html2Markdown = function(html) {
    var i, len, line, lines, markdown, options, results, turndownService;
    turndownService = new TurndownService();
    turndownService.escape = function(text) {
      return text;
    };
    turndownService.addRule('p', options = {
      filter: 'p',
      replacement: function(content, node, options) {
        // Replace non-breaking spaces with space
        content = content.replace(/\u00a0/g, ' ');
        return `\n${content}`;
      }
    });
    turndownService.addRule('timestamp', options = {
      filter: 'span',
      replacement: function(content, node, options) {
        var ms, timestamp;
        if (node.className === 'timestamp') {
          timestamp = node.dataset.timestamp;
          ms = timestamp.split('.').pop();
          return `<t ms=${ms}>${content}</t>`;
        } else {
          return content;
        }
      }
    });
    markdown = turndownService.turndown(html);
    lines = markdown.split('\n');
    results = [];
// We want blank lines between notes and timestamps, but
// keep consecutive timestamps to be tightly packed.
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (line.match(/^<t ms=/)) {
        line = `\n${line}<br>`;
      } else {
        line = line.replace(/\u00a0/g, ' ');
      }
      results.push(line);
    }
    markdown = results.join('\n');
    // Remove extra newlines between consecutive timestamps.
    return markdown = markdown.replace(/<br>\n\n/g, '<br>\n');
  };

  markdown2Html = function(markdown) {
    var groups, html, i, len, line, lines, m, matches, ms, results, s, seconds;
    lines = markdown.split('\n');
    results = [];
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (matches = line.match(mdtsRE)) {
        groups = matches.groups;
        // Convert timestamp to seconds
        m = parseInt(groups.m, 10);
        s = parseInt(groups.s, 10);
        ms = parseInt(groups.ms, 10);
        seconds = m * 60 + s + ms / 1000;
        line = line.replace(mdtsRE, `<span class="timestamp" data-timestamp="${seconds}">${groups.m}:${groups.s}</span>`);
      } else {
        // Ensure spacing preserved with non-breaking spaces.
        line = line.replace(/[ ]/g, '\u00a0');
        line = `${line}<br/>`;
      }
      results.push(line);
    }
    return html = results.join('\n');
  };

  OtrgenCommand = class OtrgenCommand extends Command {
    async run() {
      var args, html, inputFormat, lines, otr, outputFormat, resultsHtml, text, ts;
      ({flags, args} = this.parse(OtrgenCommand));
      // Show usage if no input file given.
      if (args.inputFile === '') {
        this._help();
        this.exit(0);
      }
      inputFormat = args.inputFile.split('.').pop().toLowerCase();
      outputFormat = flags.format.toLowerCase();
      if (outputFormat === 'otr' && inputFormat === 'otr') {
        outputFormat = 'md';
      }
      text = (await fs.readFile(args.inputFile, 'utf8'));
      switch (inputFormat) {
        case 'otr':
        case 'html':
        case 'htm':
          if (inputFormat === 'otr') {
            otr = JSON.parse(text);
            html = otr.text;
          } else {
            html = text;
          }
          switch (outputFormat) {
            case 'html':
              return this.log(html);
            case 'md':
              return this.log(html2Markdown(html));
            default:
              return this.error(`Unsupported output format ${outputFormat}.`);
          }
          break;
        case 'md':
          html = markdown2Html(text);
          otr = {
            text: html
          };
          switch (outputFormat) {
            case 'html':
              return this.log(html);
            case 'otr':
              return this.log(JSON.stringify(otr, 3));
            default:
              return this.error(`Unsupported output format ${outputFormat}.`);
          }
          break;
        case 'ttml':
        case 'sbv':
          lines = text.split(/\r?\n/);
          // Check for and convert TTML format to SBV
          if ((inputFormat === 'ttml') || (lines[1].match(/tt xml/))) {
            lines = ttml2sbv(lines);
          }
          resultsHtml = [];
          while (lines.length) {
            ({ts, text} = parseBlock(lines));
            resultsHtml.push(`${otrTimestamp(ts)} ${text} <br/>`);
          }
          html = resultsHtml.join('\n');
          otr = {
            text: html
          };
          switch (outputFormat) {
            case 'html':
              return this.log(html);
            case 'otr':
              return this.log(JSON.stringify(otr, 3));
            case 'md':
              return this.log(html2Markdown(html));
            default:
              return this.error(`Unsupported output format ${outputFormat}.`);
          }
          break;
        default:
          return this.error(`Unsupported input format ${inputFormat}.`);
      }
    }

  };

  OtrgenCommand.description = `Generate oTranscribe OTR files from TTML/SBV.
Converts TTML/SBV files to OTR format ready for import into oTranscribe.
Get YouTube TTML files with \`youtube-dl --write-auto-sub --sub-format ttml [YOUTUBE URL]\`.`;

  OtrgenCommand.args = [
    arg = {
      name: 'inputFile',
      required: false,
      default: ''
    }
  ];

  OtrgenCommand.flags = {
    // add --version flag to show CLI version
    version: flags.version({
      char: 'v'
    }),
    // add --help flag to show CLI version
    help: flags.help({
      char: 'h'
    }),
    format: flags.string(options = {
      char: 'f',
      description: 'Output format. (Defaults MD if input file is already OTR.)',
      default: 'otr'
    })
  };

  module.exports = OtrgenCommand;

}).call(this);
